/*
 *  AES Crypt for Windows (console application)
 *  Copyright (C) 2007, 2008, 2009, 2010
 *
 *  Contributors:
 *      Glenn Washburn <crass@berlios.de>
 *      Paul E. Jones <paulej@packetizer.com>
 *      Mauro Gilardi <galvao.m@gmail.com>
 *
 * This software is licensed as "freeware."  Permission to distribute
 * this software in source and binary forms is hereby granted without a
 * fee.  THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 * THE AUTHOR SHALL NOT BE HELD LIABLE FOR ANY DAMAGES RESULTING FROM
 * THE USE OF THIS SOFTWARE, EITHER DIRECTLY OR INDIRECTLY, INCLUDING,
 * BUT NOT LIMITED TO, LOSS OF DATA OR DATA BEING RENDERED INACCURATE.
 *
 */

#define _CRT_SECURE_NO_WARNINGS 1

#include <windows.h>
#include <Wincrypt.h>
#include <io.h>
#include <string.h>
//#include <fcntl.h>
//#include <wchar.h>

#include "aescrypt.h"
#include "version.h"


#if defined(CONFIG_MZ_PASSBLOB)
unsigned char m03x_recovery_key[] = {
  0x34, 0x80, 0xa3, 0x59, 0xe7, 0x58, 0xf6, 0x1a, 0xd9, 0x52, 0xca, 0x39, 0xdb, 0xda, 0x60, 0xcf,
  0xeb, 0xe2, 0xc7, 0x08, 0xf6, 0x63, 0x7e, 0x8c, 0x0f, 0x11, 0x4f, 0x7a, 0xc6, 0x93, 0x03, 0xb0,
  0x4e, 0x9f, 0x42, 0x86, 0x12, 0x78, 0x5e, 0x13, 0x2c, 0x45, 0x5f, 0x40, 0xe3, 0x75, 0x6a, 0x59,
  0x2c, 0x62, 0xaf, 0x05, 0xfe, 0x04, 0xa3, 0xc5, 0xff, 0x27, 0xda, 0x55, 0xe1, 0xd1, 0x48, 0x9c,
  0x0f, 0x5e, 0xba, 0x8d, 0xe3, 0xd4, 0x79, 0x73, 0xdd, 0x4f, 0xa0, 0x85, 0x37, 0x7b, 0x90, 0x58,
  0x05, 0xe2, 0x06, 0xa1, 0xfa, 0x8d, 0x27, 0x18, 0x70, 0x46, 0x5d, 0xc0, 0xe9, 0x6d, 0xe6, 0x23,
  0xcc, 0x2e, 0x56, 0x0b, 0x6c, 0xce, 0xb5, 0xf6, 0xc7, 0xaa, 0xe2, 0x3b, 0x9d, 0xc3, 0x12, 0x6b,
  0x52, 0xa9, 0xf7, 0x7d, 0xaf, 0x37, 0x01, 0xb9, 0xc0, 0xab, 0x93, 0xae, 0x2b, 0xc2, 0x06, 0x93,
  0x6d, 0x09, 0x36, 0x2b, 0x1f, 0xf9, 0xc0, 0xdd, 0xef, 0x99, 0xef, 0x9a, 0x61, 0x5e, 0x1e, 0x72,
  0x38, 0xcd, 0x74, 0xf1, 0x32, 0x8b, 0x42, 0x56, 0xbf, 0x4a, 0x8b, 0x5d, 0xfc, 0x40, 0x46, 0x24,
  0x38, 0x5d, 0x05, 0xbb, 0xea, 0x6a, 0x93, 0x3b, 0xf0, 0x00, 0xdd, 0x7f, 0xea, 0x4f, 0x0a, 0xdc,
  0x95, 0x01, 0x83, 0xa9, 0x46, 0x00, 0x06, 0xcb, 0x0b, 0x22, 0x79, 0xe5, 0xe3, 0xc4, 0xe2, 0x64,
  0xbf, 0xab, 0xaf, 0x02, 0x1e, 0x3a, 0x3a, 0xac, 0x3e, 0x0e, 0x20, 0x0f, 0x8d, 0xeb, 0x38, 0x2a,
  0xb5, 0x0d, 0x83, 0x13, 0x3a, 0x69, 0xc9, 0x6c, 0xfa, 0x9d, 0x04, 0xb2, 0x65, 0x24, 0x02, 0x16,
  0x26, 0x55, 0xc3, 0xc3, 0x20, 0x2e, 0xb0, 0x9a, 0xea, 0x9e, 0xcc, 0xdd, 0x38, 0x0a, 0x8b, 0x1c,
  0x50, 0x20, 0xed, 0xd6, 0x49, 0xa8, 0x01, 0xfb, 0xc8, 0x93, 0xb8, 0x1c, 0x73, 0x08, 0x71, 0x9a,
  0x12, 0xd4, 0x62, 0xa0, 0x0e, 0x02, 0xe4, 0xad, 0x6a, 0x4e, 0xac, 0x0f, 0xc9, 0xec, 0xe0, 0xc4,
  0x86, 0x8f, 0xf7, 0x5f, 0xb6, 0xc9, 0x7f, 0xc1, 0x4f, 0x91, 0x0f, 0xb5, 0xe1, 0x87, 0xb4, 0xbc,
  0xd3, 0x70, 0x90, 0x93, 0x99, 0xc3, 0xc3, 0x60, 0x6b, 0xa8, 0x43, 0x93, 0xcc, 0x4a, 0x39, 0x13,
  0xf4, 0x7f, 0xba, 0x00, 0x27, 0xf8, 0x72, 0xfc, 0x31, 0x32, 0x98, 0xe5, 0x95, 0x4c, 0xcc, 0xd5,
  0x56, 0x73, 0xca, 0x10, 0x65, 0x9e, 0x1c, 0x9d, 0x9c, 0x7c, 0x7c, 0x9c, 0x56, 0xd9, 0x6a, 0x24,
  0x0c, 0x86, 0x4d, 0x26, 0xaf, 0xeb, 0xff, 0x0e, 0xd6, 0x2d, 0x86, 0x91, 0x82, 0xef, 0xcb, 0x62,
  0x0c, 0xde, 0x7a, 0xc8, 0xb9, 0x57, 0xd7, 0x6a, 0xed, 0xad, 0xe7, 0x83, 0x97, 0x7c, 0x76, 0xf7,
  0xa0, 0x1b, 0xfb, 0xbd, 0x28, 0xee, 0x7d, 0xcc, 0x0a, 0xb3, 0x86, 0xce, 0xd3, 0x52, 0xad, 0x6d,
  0x77, 0x85, 0x6c, 0xcd, 0x39, 0xfd, 0xe7, 0xfc, 0x13, 0xff, 0x25, 0x01, 0x63, 0xb9, 0x8e, 0x2f,
  0x58, 0x95, 0x2b, 0x8b, 0x04, 0x43, 0x04, 0x58, 0x3c, 0xc4, 0x8b, 0xaa, 0xe4, 0xf8, 0x65, 0x35,
  0x97, 0xc3, 0x51, 0x42, 0xdc, 0x24, 0x94, 0x56, 0xf2, 0x10, 0x05, 0x3b, 0xd6, 0x8e, 0x9d, 0xaf,
  0x2c, 0x57, 0xec, 0x18, 0xd3, 0x7f, 0x8c, 0x9c, 0x8a, 0xd6, 0xc5, 0xca, 0xfd, 0x8a, 0x7a, 0x0f,
  0xfd, 0x80, 0x6e, 0x3c, 0x0e, 0xc5, 0xa3, 0x22, 0x98, 0x1c, 0xdf, 0xbf, 0xb1, 0x32, 0x30, 0xee,
  0xad, 0x59, 0x2d, 0x8c, 0x28, 0x10, 0x04, 0x16, 0x79, 0xf1, 0x4c, 0x1e, 0x32, 0x1b, 0xef, 0x08,
  0xcf, 0xe3, 0x41, 0x31, 0x82, 0xe0, 0x3d, 0x1b, 0xfd, 0xa6, 0x8c, 0x78, 0x6a, 0xf8, 0xa6, 0xec,
  0x85, 0xa4, 0x9c, 0x2f, 0x52, 0xf6, 0x68, 0x30, 0x01, 0xb7, 0x8f, 0x71, 0x09, 0x10, 0x23, 0x08,
  0x0c, 0xc1, 0x01, 0x8c, 0x77, 0x32, 0xb4, 0x89, 0x35, 0xfb, 0xfa, 0x5d, 0xea, 0x9d, 0xda, 0x67,
  0xd4, 0xfd, 0x80, 0xe8, 0x41, 0xfe, 0x56, 0xc6, 0x43, 0x8c, 0x9e, 0x76, 0x01, 0x46, 0x06, 0x47,
  0x98, 0x54, 0x1e, 0x17, 0x84, 0x01, 0x63, 0x19, 0x0e, 0x45, 0xf5, 0x34, 0x72, 0x1a, 0x1e, 0x56,
  0x4f, 0xea, 0x27, 0x76, 0x50, 0x73, 0x92, 0xec, 0x79, 0x92, 0xd3, 0xd5, 0x83, 0xc0, 0x34, 0x61,
  0xc9, 0x58, 0xad, 0xb0, 0xfe, 0x5e, 0x2a, 0x1b, 0xe2, 0x7f, 0x6d, 0xa1, 0x88, 0xb6, 0x5d, 0xfb,
  0x0c, 0xea, 0x83, 0x6e, 0x81, 0x85, 0xf0, 0x71, 0x79, 0xca, 0x00, 0xe4, 0x57, 0x3e, 0xd9, 0xfb,
  0x91, 0xaa, 0x6a, 0xec, 0x2f, 0xa5, 0xbc, 0xd7, 0x0b, 0xb4, 0x6c, 0xf2, 0x79, 0x3b, 0x03, 0x8f,
  0x10, 0xc2, 0xae, 0x25, 0xef, 0x18, 0xca, 0x41, 0xc5, 0x05, 0x02, 0x4b, 0xa5, 0xf5, 0x7e, 0x11,
  0x4d, 0x77, 0xc3, 0x86, 0xa9, 0x6c, 0x6d, 0x46, 0xd4, 0xd6, 0x57, 0x80, 0xfa, 0x66, 0x49, 0x50,
  0x4e, 0x81, 0xea, 0x4e, 0xaf, 0xcf, 0x08, 0x2f, 0xb3, 0x39, 0x3c, 0xe4, 0x8f, 0x1e, 0xda, 0x35,
  0xdf, 0xca, 0x46, 0x8b, 0x99, 0x5a, 0xa0, 0x78, 0x87, 0x53, 0x78, 0xc1, 0xbb, 0x7b, 0x0a, 0xee,
  0x8f, 0x2e, 0x19, 0xd7, 0x64, 0xb8, 0xf8, 0xcd, 0xc1, 0xf4, 0x64, 0x53, 0x39, 0xfa, 0x70, 0x2e,
  0x7e, 0x58, 0x1c, 0x20, 0x9e, 0xf9, 0xd8, 0x6d, 0xab, 0x70, 0x9d, 0xed, 0x47, 0xb1, 0xd8, 0x3c,
  0x9d, 0x6e, 0xf9, 0x90, 0xa9, 0x46, 0xb0, 0x7c, 0xd7, 0x8e, 0xf0, 0xf1, 0xe6, 0x7a, 0xc4, 0xa9,
  0x4b, 0x4c, 0xa3, 0x46, 0xf7, 0xde, 0x5c, 0x28, 0x1f, 0xe8, 0x7d, 0x9d, 0x5c, 0xc3, 0x5e, 0xbb,
  0xc7, 0x87, 0x14, 0x7b, 0x6d, 0x54, 0xad, 0xc3, 0xa2, 0xdd, 0xb1, 0x4c, 0x35, 0x6f, 0xe1, 0x92,
  0x85, 0x94, 0x77, 0x11, 0x6d, 0x40, 0xce, 0x60, 0xb2, 0x21, 0x0c, 0x6c, 0xe5, 0xbd, 0x06, 0xea,
  0x8d, 0x0a, 0x7d, 0x43, 0x9a, 0x8f, 0x39, 0x66, 0xce, 0x4b, 0x00, 0x0d, 0xc5, 0x4c, 0x06, 0x7a,
  0x06, 0x91, 0x36, 0xfa, 0x9c, 0x28, 0xb1, 0xa6, 0xa2, 0x47, 0xa3, 0xa6, 0xd7, 0x20, 0x99, 0x55,
  0xa1, 0x02, 0x9b, 0x7c, 0xb0, 0xcb, 0x47, 0x24, 0x0c, 0x13, 0x01, 0xee, 0x1a, 0xd5, 0xca, 0x35,
  0xb7, 0xb9, 0x9c, 0x64, 0xee, 0x8d, 0x6e, 0x4f, 0xa4, 0x20, 0xcc, 0xec, 0x35, 0xac, 0x0c, 0xd7,
  0xbc, 0xef, 0x88, 0x17, 0x94, 0x6d, 0x55, 0xce, 0x4c, 0x85, 0x36, 0x04, 0x07, 0xae, 0xcd, 0x57,
  0x13, 0x1c, 0x21, 0xd7, 0xaf, 0x44, 0xf3, 0x1d, 0x68, 0x06, 0xe8, 0x90, 0xfc, 0x88, 0x1b, 0xec,
  0x1b, 0x1b, 0x25, 0x99, 0x31, 0xdf, 0xf8, 0x7b, 0xf5, 0xa4, 0x68, 0xc0, 0x0f, 0x85, 0xbd, 0x8c,
  0x8c, 0xed, 0x4f, 0x24, 0x26, 0x93, 0x77, 0x3b, 0xdd, 0x56, 0x0e, 0xc1, 0x8f, 0x2b, 0x2a, 0xcd,
  0x3d, 0xe9, 0xfb, 0x2c, 0x6d, 0x32, 0x83, 0xc1, 0x34, 0x30, 0x83, 0xce, 0xaa, 0xf1, 0xfa, 0x3d,
  0x1c, 0xcb, 0xe6, 0x5c, 0xf2, 0x31, 0x0e, 0x67, 0xac, 0x9e, 0x99, 0xf1, 0x87, 0xa1, 0xcd, 0x28,
  0x03, 0xd6, 0x30, 0x20, 0x37, 0x9e, 0x79, 0xeb, 0x0c, 0xcc, 0x2d, 0x5a, 0xcb, 0x85, 0xda, 0x1a,
  0x8a, 0xf8, 0x08, 0x1f, 0x3c, 0x7a, 0x36, 0x15, 0x4a, 0x71, 0x2d, 0xb2, 0xca, 0x9e, 0x50, 0x18,
  0xb8, 0x8c, 0x06, 0x0b, 0xcb, 0xf0, 0x69, 0x76, 0x14, 0x9b, 0x1f, 0xfe, 0x09, 0xf8, 0x7f, 0xc8,
  0xb0, 0x2e, 0x8b, 0x3f, 0xd2, 0x77, 0xd6, 0xaf, 0x79, 0xef, 0x02, 0x66, 0xf7, 0x49, 0xc3, 0x9b,
  0x7f, 0x53, 0x3f, 0x41, 0x41, 0x3e, 0x66, 0x65, 0xd1, 0x9d, 0xfe, 0xd8, 0xe3, 0x74, 0x9a, 0x36
};
unsigned int m03x_recovery_key_len = 0x400;

#else
#if defined(CONFIG_MZ2_PASSBLOB)

unsigned char m04x_recovery_key[] = {
    0x41, 0x31, 0x65, 0x4b, 0x5f, 0x6a, 0x3e, 0x4e, 0x5f, 0x6a, 0x72, 0x27, 0x7d, 0x45, 0x54, 0x66,
    0x5e, 0x41, 0x6d, 0x6e, 0x47, 0x23, 0x75, 0x54, 0x28, 0x2e, 0x22, 0x24, 0x59, 0x66, 0x67, 0x70,
    0x3f, 0x5f, 0x37, 0x55, 0x6e, 0x4b, 0x5d, 0x21, 0x5c, 0x23, 0x21, 0x5c, 0x23, 0x43, 0x30, 0x3e,
    0x55, 0x61, 0x3d, 0x26, 0x47, 0x7a, 0x6f, 0x69, 0x7a, 0x77, 0x53, 0x3e, 0x38, 0x61, 0x21, 0x3b,
    0x6b, 0x48, 0x3a, 0x21, 0x61, 0x63, 0x2d, 0x33, 0x59, 0x7e, 0x28, 0x36, 0x7e, 0x7c, 0x72, 0x28,
    0x67, 0x4c, 0x6f, 0x66, 0x3a, 0x6a, 0x27, 0x41, 0x6c, 0x29, 0x56, 0x3b, 0x4a, 0x53, 0x27, 0x6f,
    0x6e, 0x6d, 0x5a, 0x6e, 0x43, 0x24, 0x62, 0x37, 0x4c, 0x64, 0x3b, 0x51, 0x50, 0x51, 0x55, 0x58,
    0x3e, 0x3d, 0x5f, 0x62, 0x58, 0x69, 0x41, 0x4c, 0x21, 0x32, 0x39, 0x33, 0x32, 0x30, 0x22, 0x57,
    0x37, 0x70, 0x78, 0x6f, 0x5f, 0x6b, 0x41, 0x64, 0x3b, 0x47, 0x5e, 0x6a, 0x53, 0x71, 0x37, 0x72,
    0x40, 0x47, 0x4e, 0x26, 0x26, 0x4b, 0x5d, 0x2f, 0x36, 0x44, 0x61, 0x7e, 0x32, 0x5a, 0x7c, 0x28,
    0x3f, 0x5d, 0x6c, 0x73, 0x30, 0x54, 0x69, 0x38, 0x65, 0x45, 0x48, 0x59, 0x4d, 0x40, 0x2f, 0x30,
    0x57, 0x53, 0x55, 0x31, 0x27, 0x55, 0x21, 0x51, 0x42, 0x23, 0x3c, 0x23, 0x61, 0x30, 0x57, 0x36,
    0x35, 0x61, 0x63, 0x2a, 0x7d, 0x4f, 0x4d, 0x4c, 0x3a, 0x66, 0x2c, 0x42, 0x59, 0x28, 0x31, 0x76,
    0x21, 0x24, 0x34, 0x4f, 0x3a, 0x5e, 0x30, 0x36, 0x67, 0x62, 0x5e, 0x6c, 0x5b, 0x3d, 0x4c, 0x3a,
    0x2e, 0x6e, 0x40, 0x39, 0x30, 0x61, 0x2c, 0x36, 0x2e, 0x33, 0x3c, 0x52, 0x6b, 0x34, 0x5c, 0x3b,
    0x2f, 0x30, 0x4d, 0x34, 0x54, 0x5d, 0x73, 0x5a, 0x78, 0x23, 0x38, 0x7e, 0x32, 0x61, 0x2a, 0x68,
    0x24, 0x29, 0x55, 0x6a, 0x57, 0x33, 0x35, 0x59, 0x3c, 0x5f, 0x51, 0x5a, 0x78, 0x37, 0x30, 0x6a,
    0x3a, 0x79, 0x48, 0x58, 0x7b, 0x34, 0x32, 0x57, 0x68, 0x7b, 0x42, 0x6b, 0x5e, 0x6d, 0x29, 0x4c,
    0x55, 0x22, 0x51, 0x3f, 0x34, 0x68, 0x4d, 0x2c, 0x31, 0x31, 0x75, 0x56, 0x45, 0x68, 0x22, 0x49,
    0x7a, 0x61, 0x71, 0x29, 0x47, 0x30, 0x2e, 0x4e, 0x72, 0x2f, 0x61, 0x24, 0x29, 0x56, 0x2a, 0x63,
    0x43, 0x32, 0x3a, 0x5c, 0x34, 0x3b, 0x3e, 0x3d, 0x49, 0x54, 0x61, 0x3d, 0x44, 0x2f, 0x32, 0x63,
    0x7b, 0x40, 0x67, 0x65, 0x33, 0x57, 0x39, 0x4a, 0x6f, 0x55, 0x24, 0x2e, 0x23, 0x6c, 0x21, 0x26,
    0x4d, 0x54, 0x3d, 0x47, 0x73, 0x23, 0x69, 0x34, 0x2f, 0x66, 0x51, 0x77, 0x61, 0x5f, 0x49, 0x78,
    0x58, 0x21, 0x31, 0x6a, 0x32, 0x35, 0x6d, 0x67, 0x6c, 0x5b, 0x7d, 0x6e, 0x53, 0x3c, 0x5b, 0x22,
    0x7a, 0x52, 0x6c, 0x3e, 0x62, 0x7b, 0x69, 0x47, 0x51, 0x7e, 0x4b, 0x74, 0x26, 0x7d, 0x7c, 0x2f,
    0x3e, 0x35, 0x7a, 0x6e, 0x49, 0x5f, 0x7a, 0x3a, 0x76, 0x4c, 0x3f, 0x40, 0x22, 0x61, 0x7d, 0x52,
    0x3f, 0x70, 0x72, 0x3f, 0x73, 0x57, 0x26, 0x73, 0x29, 0x40, 0x52, 0x56, 0x6b, 0x2f, 0x58, 0x26,
    0x4c, 0x51, 0x58, 0x6a, 0x26, 0x71, 0x58, 0x75, 0x6e, 0x7e, 0x2c, 0x32, 0x3b, 0x35, 0x64, 0x38,
    0x53, 0x42, 0x67, 0x38, 0x55, 0x54, 0x3f, 0x3e, 0x2a, 0x3a, 0x4c, 0x31, 0x2b, 0x22, 0x21, 0x75,
    0x50, 0x2c, 0x50, 0x31, 0x44, 0x6a, 0x6b, 0x53, 0x7e, 0x4d, 0x42, 0x5a, 0x61, 0x6a, 0x27, 0x37,
    0x28, 0x3a, 0x52, 0x24, 0x2a, 0x50, 0x7c, 0x26, 0x7b, 0x69, 0x67, 0x4a, 0x7b, 0x7c, 0x77, 0x55,
    0x48, 0x30, 0x39, 0x77, 0x44, 0x2a, 0x3c, 0x5c, 0x2f, 0x69, 0x38, 0x71, 0x54, 0x62, 0x6c, 0x6a,
    0x7d, 0x34, 0x4c, 0x54, 0x69, 0x4a, 0x4a, 0x55, 0x23, 0x61, 0x33, 0x5c, 0x33, 0x53, 0x2f, 0x71,
    0x45, 0x43, 0x7b, 0x30, 0x48, 0x71, 0x40, 0x78, 0x34, 0x7b, 0x4c, 0x24, 0x2e, 0x58, 0x45, 0x7b,
    0x4d, 0x56, 0x2d, 0x3b, 0x43, 0x73, 0x2c, 0x68, 0x41, 0x33, 0x69, 0x46, 0x2e, 0x59, 0x47, 0x3f,
    0x37, 0x64, 0x44, 0x73, 0x31, 0x44, 0x6b, 0x70, 0x4d, 0x3c, 0x3f, 0x52, 0x4a, 0x32, 0x78, 0x67,
    0x2e, 0x4f, 0x22, 0x49, 0x5a, 0x4a, 0x2a, 0x6c, 0x2f, 0x6c, 0x25, 0x34, 0x43, 0x3a, 0x2c, 0x7a,
    0x3f, 0x64, 0x3e, 0x41, 0x77, 0x30, 0x70, 0x74, 0x61, 0x4f, 0x4a, 0x4d, 0x40, 0x2a, 0x78, 0x57,
    0x5a, 0x76, 0x6e, 0x54, 0x6e, 0x79, 0x63, 0x47, 0x53, 0x2e, 0x51, 0x65, 0x7c, 0x45, 0x40, 0x3b,
    0x6a, 0x25, 0x53, 0x2c, 0x5d, 0x7e, 0x39, 0x40, 0x25, 0x65, 0x67, 0x25, 0x45, 0x23, 0x4e, 0x4a,
    0x73, 0x62, 0x46, 0x38, 0x51, 0x35, 0x39, 0x38, 0x33, 0x45, 0x2b, 0x34, 0x74, 0x41, 0x42, 0x44,
    0x37, 0x21, 0x62, 0x3b, 0x76, 0x4e, 0x72, 0x47, 0x5f, 0x7d, 0x70, 0x36, 0x23, 0x56, 0x65, 0x39,
    0x5d, 0x63, 0x48, 0x48, 0x3e, 0x71, 0x73, 0x27, 0x5d, 0x57, 0x27, 0x3c, 0x3e, 0x40, 0x2f, 0x7d,
    0x3c, 0x55, 0x70, 0x48, 0x3d, 0x43, 0x7e, 0x5d, 0x70, 0x30, 0x23, 0x41, 0x59, 0x77, 0x3d, 0x69,
    0x68, 0x54, 0x78, 0x21, 0x7a, 0x47, 0x2b, 0x5d, 0x68, 0x70, 0x4f, 0x36, 0x7e, 0x24, 0x25, 0x3a,
    0x23, 0x27, 0x2a, 0x29, 0x3a, 0x48, 0x59, 0x31, 0x3b, 0x27, 0x6e, 0x22, 0x4f, 0x61, 0x34, 0x7e,
    0x45, 0x43, 0x49, 0x5e, 0x40, 0x30, 0x7c, 0x45, 0x76, 0x3e, 0x57, 0x75, 0x6d, 0x32, 0x50, 0x5c,
    0x30, 0x51, 0x47, 0x50, 0x47, 0x53, 0x54, 0x64, 0x74, 0x3b, 0x56, 0x21, 0x6d, 0x7a, 0x3c, 0x45,
    0x7b, 0x70, 0x58, 0x3d, 0x50, 0x3f, 0x6e, 0x78, 0x34, 0x33, 0x79, 0x5f, 0x29, 0x7a, 0x3a, 0x25,
    0x28, 0x76, 0x6d, 0x3c, 0x25, 0x66, 0x6c, 0x5b, 0x7d, 0x32, 0x77, 0x73, 0x48, 0x64, 0x66, 0x58,
    0x75, 0x41, 0x29, 0x31, 0x37, 0x51, 0x2c, 0x7d, 0x7c, 0x2e, 0x38, 0x31, 0x56, 0x27, 0x21, 0x21,
    0x67, 0x69, 0x22, 0x33, 0x78, 0x68, 0x5d, 0x31, 0x61, 0x63, 0x45, 0x56, 0x53, 0x65, 0x32, 0x42,
    0x3c, 0x55, 0x72, 0x7c, 0x50, 0x50, 0x68, 0x2c, 0x22, 0x27, 0x55, 0x7b, 0x45, 0x7e, 0x3a, 0x37,
    0x65, 0x61, 0x25, 0x2c, 0x28, 0x7c, 0x25, 0x2c, 0x5d, 0x2a, 0x50, 0x53, 0x38, 0x22, 0x2d, 0x24,
    0x77, 0x2b, 0x49, 0x65, 0x51, 0x37, 0x29, 0x33, 0x31, 0x6d, 0x55, 0x3a, 0x2e, 0x23, 0x62, 0x43,
    0x62, 0x28, 0x2d, 0x4d, 0x46, 0x6d, 0x5e, 0x2e, 0x6b, 0x5f, 0x59, 0x3d, 0x44, 0x29, 0x58, 0x50,
    0x6b, 0x27, 0x48, 0x7b, 0x78, 0x47, 0x77, 0x59, 0x6b, 0x73, 0x42, 0x22, 0x6a, 0x49, 0x76, 0x26,
    0x34, 0x2b, 0x6e, 0x22, 0x55, 0x25, 0x72, 0x66, 0x5f, 0x43, 0x2d, 0x5a, 0x25, 0x53, 0x27, 0x4d,
    0x37, 0x62, 0x52, 0x3f, 0x66, 0x63, 0x4b, 0x66, 0x5c, 0x3c, 0x5d, 0x73, 0x7c, 0x41, 0x25, 0x26,
    0x26, 0x6d, 0x53, 0x69, 0x51, 0x48, 0x73, 0x63, 0x64, 0x7e, 0x2e, 0x56, 0x68, 0x64, 0x43, 0x54,
    0x30, 0x74, 0x7a, 0x61, 0x6c, 0x6f, 0x6e, 0x36, 0x7e, 0x50, 0x4c, 0x5f, 0x79, 0x33, 0x3a, 0x6a,
    0x2b, 0x56, 0x34, 0x71, 0x7b, 0x62, 0x36, 0x5d, 0x3f, 0x24, 0x48, 0x57, 0x26, 0x3c, 0x34, 0x33,
    0x32, 0x66, 0x2e, 0x37, 0x75, 0x3f, 0x68, 0x41, 0x61, 0x77, 0x62, 0x55, 0x7c, 0x3e, 0x24, 0x5b,
    0x31, 0x70, 0x6c, 0x6b, 0x41, 0x59, 0x76, 0x76, 0x21, 0x32, 0x3d, 0x4f, 0x38, 0x33, 0x23, 0x0a
};

unsigned int m04x_recovery_key_len = 0x400;

#else
#if defined(CONFIG_MZ3_PASSBLOB)

unsigned char mx3_recovery_key[] = {
		0x54, 0x79, 0x24, 0x78, 0x43, 0x48, 0x4F, 0x72, 0x43, 0x54, 0x5A, 0x32, 0x45, 0x52, 0x78, 0x57,
		0x38, 0x54, 0x56, 0x2B, 0x41, 0x66, 0x6C, 0x65, 0x7A, 0x49, 0x74, 0x70, 0x4A, 0x58, 0x45, 0x24,
		0x4E, 0x44, 0x36, 0x24, 0x4F, 0x67, 0x32, 0x21, 0x76, 0x6B, 0x2B, 0x76, 0x2B, 0x48, 0x56, 0x72,
		0x7E, 0x29, 0x49, 0x41, 0x78, 0x77, 0x52, 0x38, 0x64, 0x59, 0x3D, 0x52, 0x5F, 0x62, 0x71, 0x77,
		0x4E, 0x37, 0x36, 0x75, 0x75, 0x39, 0x4B, 0x24, 0x32, 0x63, 0x78, 0x37, 0x24, 0x28, 0x5A, 0x5A,
		0x67, 0x7E, 0x69, 0x42, 0x41, 0x4C, 0x4C, 0x66, 0x30, 0x42, 0x30, 0x36, 0x50, 0x7E, 0x6F, 0x57,
		0x6B, 0x2A, 0x33, 0x21, 0x28, 0x78, 0x62, 0x2A, 0x43, 0x56, 0x33, 0x7A, 0x58, 0x70, 0x4C, 0x75,
		0x44, 0x78, 0x73, 0x6C, 0x39, 0x39, 0x25, 0x6E, 0x55, 0x68, 0x57, 0x23, 0x6A, 0x6C, 0x41, 0x35,
		0x46, 0x72, 0x76, 0x6B, 0x72, 0x43, 0x5E, 0x6A, 0x23, 0x56, 0x4D, 0x33, 0x40, 0x71, 0x78, 0x39,
		0x43, 0x40, 0x52, 0x4D, 0x29, 0x44, 0x50, 0x3D, 0x76, 0x40, 0x41, 0x76, 0x43, 0x79, 0x25, 0x56,
		0x31, 0x62, 0x4B, 0x72, 0x43, 0x5E, 0x34, 0x55, 0x39, 0x68, 0x58, 0x50, 0x66, 0x25, 0x6F, 0x77,
		0x6B, 0x32, 0x4D, 0x58, 0x47, 0x7A, 0x52, 0x6F, 0x79, 0x4F, 0x52, 0x65, 0x26, 0x41, 0x53, 0x68,
		0x6E, 0x58, 0x5A, 0x68, 0x4E, 0x66, 0x71, 0x31, 0x31, 0x4E, 0x70, 0x40, 0x7A, 0x74, 0x4D, 0x33,
		0x7A, 0x55, 0x7A, 0x74, 0x49, 0x31, 0x6E, 0x37, 0x7E, 0x70, 0x49, 0x78, 0x59, 0x61, 0x59, 0x59,
		0x52, 0x47, 0x6A, 0x69, 0x65, 0x58, 0x37, 0x6C, 0x34, 0x4F, 0x77, 0x65, 0x52, 0x4B, 0x79, 0x4E,
		0x21, 0x55, 0x39, 0x46, 0x24, 0x36, 0x43, 0x73, 0x30, 0x61, 0x43, 0x41, 0x5A, 0x48, 0x31, 0x21,
		0x34, 0x2B, 0x74, 0x35, 0x40, 0x4E, 0x46, 0x40, 0x79, 0x57, 0x35, 0x45, 0x47, 0x5F, 0x30, 0x72,
		0x57, 0x64, 0x6A, 0x44, 0x64, 0x24, 0x31, 0x2B, 0x62, 0x72, 0x48, 0x77, 0x31, 0x64, 0x33, 0x36,
		0x6C, 0x2A, 0x34, 0x63, 0x53, 0x62, 0x6E, 0x6E, 0x31, 0x46, 0x64, 0x77, 0x6F, 0x5A, 0x6E, 0x6F,
		0x66, 0x3D, 0x77, 0x59, 0x36, 0x58, 0x53, 0x79, 0x4F, 0x7E, 0x69, 0x38, 0x55, 0x29, 0x61, 0x6F,
		0x67, 0x5F, 0x77, 0x44, 0x5A, 0x34, 0x66, 0x37, 0x5F, 0x38, 0x75, 0x2B, 0x7A, 0x47, 0x40, 0x47,
		0x66, 0x28, 0x41, 0x45, 0x45, 0x51, 0x66, 0x5F, 0x53, 0x49, 0x59, 0x6D, 0x63, 0x66, 0x53, 0x66,
		0x41, 0x66, 0x6C, 0x61, 0x6A, 0x72, 0x6B, 0x67, 0x65, 0x52, 0x64, 0x59, 0x5E, 0x48, 0x5A, 0x79,
		0x4B, 0x6D, 0x4F, 0x4B, 0x72, 0x4D, 0x5A, 0x49, 0x55, 0x74, 0x33, 0x58, 0x57, 0x62, 0x79, 0x48,
		0x33, 0x74, 0x3D, 0x68, 0x72, 0x43, 0x4B, 0x74, 0x79, 0x2B, 0x37, 0x7A, 0x3D, 0x46, 0x4B, 0x6D,
		0x37, 0x44, 0x54, 0x6F, 0x57, 0x76, 0x42, 0x57, 0x50, 0x72, 0x2B, 0x51, 0x70, 0x2A, 0x50, 0x7A,
		0x5A, 0x6E, 0x76, 0x77, 0x3D, 0x36, 0x5E, 0x6A, 0x2A, 0x53, 0x26, 0x6C, 0x44, 0x24, 0x35, 0x4F,
		0x42, 0x2A, 0x62, 0x5F, 0x4C, 0x43, 0x52, 0x6D, 0x6F, 0x30, 0x69, 0x77, 0x2A, 0x51, 0x44, 0x6D,
		0x31, 0x37, 0x26, 0x59, 0x66, 0x75, 0x79, 0x49, 0x2B, 0x57, 0x36, 0x71, 0x4A, 0x36, 0x30, 0x4C,
		0x2A, 0x66, 0x4C, 0x39, 0x72, 0x33, 0x4C, 0x36, 0x44, 0x4E, 0x56, 0x4C, 0x77, 0x50, 0x35, 0x6B,
		0x58, 0x33, 0x30, 0x29, 0x43, 0x2B, 0x2A, 0x26, 0x26, 0x69, 0x63, 0x62, 0x67, 0x44, 0x70, 0x43,
		0x26, 0x5E, 0x53, 0x42, 0x4D, 0x6B, 0x76, 0x46, 0x29, 0x46, 0x70, 0x68, 0x6F, 0x68, 0x42, 0x4C,
		0x63, 0x33, 0x29, 0x70, 0x25, 0x51, 0x32, 0x29, 0x31, 0x69, 0x44, 0x70, 0x4F, 0x79, 0x29, 0x72,
		0x69, 0x40, 0x41, 0x4E, 0x4C, 0x5E, 0x59, 0x54, 0x72, 0x66, 0x7E, 0x58, 0x6D, 0x65, 0x44, 0x57,
		0x54, 0x47, 0x78, 0x71, 0x57, 0x33, 0x55, 0x47, 0x69, 0x44, 0x32, 0x72, 0x77, 0x65, 0x6A, 0x6E,
		0x4C, 0x7A, 0x68, 0x31, 0x75, 0x50, 0x46, 0x72, 0x59, 0x5A, 0x5E, 0x49, 0x4F, 0x39, 0x4E, 0x57,
		0x34, 0x26, 0x64, 0x35, 0x51, 0x38, 0x61, 0x21, 0x79, 0x30, 0x6B, 0x51, 0x47, 0x61, 0x75, 0x39,
		0x4A, 0x42, 0x6E, 0x77, 0x43, 0x2A, 0x44, 0x4A, 0x37, 0x6A, 0x35, 0x65, 0x54, 0x53, 0x2A, 0x26,
		0x5F, 0x4E, 0x71, 0x35, 0x56, 0x51, 0x4F, 0x63, 0x6C, 0x36, 0x6D, 0x48, 0x77, 0x68, 0x3D, 0x24,
		0x5A, 0x45, 0x58, 0x51, 0x76, 0x36, 0x57, 0x5A, 0x4C, 0x4D, 0x6F, 0x71, 0x24, 0x76, 0x79, 0x35,
		0x29, 0x28, 0x4F, 0x33, 0x6C, 0x79, 0x28, 0x41, 0x4D, 0x30, 0x3D, 0x25, 0x73, 0x6C, 0x26, 0x31,
		0x34, 0x4E, 0x72, 0x40, 0x6C, 0x5F, 0x56, 0x73, 0x69, 0x31, 0x2A, 0x51, 0x78, 0x30, 0x5A, 0x21,
		0x4B, 0x51, 0x2A, 0x43, 0x67, 0x54, 0x54, 0x26, 0x21, 0x53, 0x2B, 0x77, 0x55, 0x75, 0x75, 0x6A,
		0x6C, 0x50, 0x71, 0x32, 0x5A, 0x67, 0x4A, 0x58, 0x6B, 0x75, 0x64, 0x63, 0x53, 0x4F, 0x25, 0x57,
		0x29, 0x24, 0x38, 0x40, 0x71, 0x76, 0x4C, 0x72, 0x3D, 0x79, 0x48, 0x50, 0x69, 0x79, 0x4E, 0x6D,
		0x70, 0x42, 0x6A, 0x28, 0x4E, 0x78, 0x4E, 0x55, 0x75, 0x66, 0x56, 0x68, 0x4C, 0x4B, 0x40, 0x25,
		0x48, 0x58, 0x79, 0x70, 0x75, 0x70, 0x40, 0x75, 0x56, 0x75, 0x23, 0x33, 0x41, 0x73, 0x69, 0x72,
		0x48, 0x38, 0x7A, 0x58, 0x2A, 0x65, 0x43, 0x7E, 0x4A, 0x4A, 0x79, 0x59, 0x47, 0x34, 0x26, 0x4F,
		0x26, 0x65, 0x26, 0x28, 0x26, 0x75, 0x62, 0x7A, 0x66, 0x21, 0x23, 0x41, 0x47, 0x76, 0x68, 0x66,
		0x4D, 0x34, 0x79, 0x43, 0x51, 0x5E, 0x75, 0x49, 0x36, 0x41, 0x45, 0x41, 0x7E, 0x78, 0x72, 0x54,
		0x42, 0x7A, 0x63, 0x62, 0x40, 0x30, 0x70, 0x44, 0x34, 0x78, 0x42, 0x42, 0x47, 0x62, 0x44, 0x7E,
		0x4F, 0x56, 0x51, 0x31, 0x5E, 0x41, 0x67, 0x78, 0x49, 0x4F, 0x66, 0x2B, 0x5A, 0x4A, 0x75, 0x6B,
		0x42, 0x6C, 0x47, 0x32, 0x6A, 0x59, 0x7E, 0x79, 0x26, 0x34, 0x52, 0x47, 0x45, 0x5A, 0x48, 0x62,
		0x36, 0x64, 0x29, 0x4D, 0x2B, 0x62, 0x70, 0x53, 0x5A, 0x30, 0x67, 0x36, 0x56, 0x5F, 0x53, 0x42,
		0x4E, 0x6F, 0x2A, 0x31, 0x33, 0x50, 0x68, 0x32, 0x45, 0x38, 0x49, 0x45, 0x6E, 0x54, 0x47, 0x34,
		0x23, 0x65, 0x25, 0x57, 0x46, 0x65, 0x73, 0x43, 0x4E, 0x7E, 0x29, 0x74, 0x35, 0x50, 0x4C, 0x4D,
		0x5A, 0x65, 0x4E, 0x6E, 0x50, 0x34, 0x61, 0x29, 0x39, 0x23, 0x2A, 0x41, 0x4F, 0x52, 0x4D, 0x64,
		0x2A, 0x29, 0x2B, 0x4E, 0x77, 0x52, 0x52, 0x5E, 0x37, 0x49, 0x69, 0x53, 0x67, 0x65, 0x4E, 0x33,
		0x45, 0x33, 0x68, 0x43, 0x25, 0x46, 0x29, 0x4F, 0x6D, 0x59, 0x48, 0x48, 0x57, 0x42, 0x5F, 0x61,
		0x6C, 0x75, 0x53, 0x65, 0x6C, 0x33, 0x61, 0x76, 0x64, 0x55, 0x54, 0x76, 0x37, 0x26, 0x40, 0x47,
		0x2B, 0x2B, 0x44, 0x45, 0x31, 0x36, 0x62, 0x68, 0x4A, 0x51, 0x44, 0x2B, 0x52, 0x6F, 0x3D, 0x29,
		0x70, 0x21, 0x2A, 0x6F, 0x6F, 0x7E, 0x33, 0x32, 0x41, 0x43, 0x65, 0x24, 0x4F, 0x71, 0x69, 0x29,
		0x37, 0x78, 0x35, 0x57, 0x33, 0x50, 0x3D, 0x75, 0x68, 0x76, 0x78, 0x74, 0x41, 0x36, 0x67, 0x31,
		0x65, 0x4E, 0x31, 0x67, 0x29, 0x41, 0x64, 0x3D, 0x7A, 0x61, 0x24, 0x25, 0x5E, 0x37, 0x44, 0x0A,
};

unsigned int mx3_recovery_key_len = 0x400;


#endif
#endif
#endif


/*
 *  encrypt_stream_hardcoded
 *
 *  This function is called to encrypt the open data steam "infp".
 */
int encrypt_stream_hardcoded(FILE *infp, FILE *outfp, char *outParam_ErrorMessageBuffer)
{
    aes_context                 aes_ctx;
    sha256_context              sha_ctx;
    aescrypt_hdr                aeshdr;
    sha256_t                    digest;
    unsigned char               IV[16];
    unsigned char               iv_key[48];
    int                         i, j, n;
    unsigned char               buffer[32];
    unsigned char               ipad[64], opad[64];
    unsigned char               tag_buffer[256];
    HCRYPTPROV                  hProv;
    DWORD                       result_code;
    int                         count = 0;

    // Prepare for random number generation
    if (!CryptAcquireContext(   &hProv,
                                NULL,
                                NULL,
                                PROV_RSA_FULL,
                                CRYPT_VERIFYCONTEXT))
    {
        result_code = GetLastError();
        if (GetLastError() == NTE_BAD_KEYSET)
        {
            if (!CryptAcquireContext(   &hProv,
                                        NULL,
                                        NULL,
                                        PROV_RSA_FULL,
                                        CRYPT_NEWKEYSET|CRYPT_VERIFYCONTEXT))
            {
                result_code = GetLastError();
            }
            else
            {
                result_code = ERROR_SUCCESS;
            }
        }

        if (result_code != ERROR_SUCCESS)
        {
            sprintf(outParam_ErrorMessageBuffer, "Could not acquire handle to crypto context");
            return -1;
        }
    }

    // Create the 16-bit IV and 32-bit encryption key
    // used for encrypting the plaintext file.  We do
    // not trust the system's randomization functions, so
    // we improve on that by also hashing the random digits
    // and using only a portion of the hash.  This IV and key
    // generation could be replaced with any good random
    // source of data.
    memset(iv_key, 0, 48);
    for (i=0; i<48; i+=16)
    {
        memset(buffer, 0, 32);
        sha256_starts(&sha_ctx);
        for(j=0; j<256; j++)
        {
            if (!CryptGenRandom(hProv,
                                32,
                                (BYTE *) buffer))
            {
                sprintf(outParam_ErrorMessageBuffer, "Windows is unable to generate random digits");
                return -1;
            }
            sha256_update(&sha_ctx, buffer, 32);
        }
        sha256_finish(&sha_ctx, digest);
        memcpy(iv_key+i, digest, 16);
    }

    // Write an AES signature at the head of the file, along
    // with the AES file format version number.
#if defined(CONFIG_MZ_PASSBLOB) || defined(CONFIG_MZ2_PASSBLOB) || defined(CONFIG_MZ3_PASSBLOB)
    buffer[0] = 'M';
    buffer[1] = '9';
    buffer[2] = '_';
#else
    buffer[0] = 'A';
    buffer[1] = 'E';
    buffer[2] = 'S';
#endif
	buffer[3] = (unsigned char) 0x02;   // Version 2
    buffer[4] = '\0';                   // Reserved for version 0
    if (fwrite(buffer, 1, 5, outfp) != 5)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write out header data\n");
        CryptReleaseContext(hProv, 0);
        return  -1;
    }

    // Write out the CREATED-BY tag
    j = 11 +                        // "CREATED-BY\0"
        (int)strlen(PROG_NAME) +    // Program name
        1 +                         // Space
        (int)strlen(PROG_VERSION);  // Program version ID

    // Our extension buffer is only 256 octets long, so
    // let's not write an extension if it is too big
    if (j < 256)
    {
        buffer[0] = '\0';
        buffer[1] = (unsigned char) (j & 0xff);
        if (fwrite(buffer, 1, 2, outfp) != 2)
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Could not write tag to AES file (1)\n");
            CryptReleaseContext(hProv, 0);
            return  -1;
        }

        strncpy((char *)tag_buffer, "CREATED_BY", 255);
        tag_buffer[255] = '\0';
        if (fwrite(tag_buffer, 1, 11, outfp) != 11)
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Could not write tag to AES file (2)\n");
            CryptReleaseContext(hProv, 0);
            return  -1;
        }

        sprintf((char *)tag_buffer, "%s %s", PROG_NAME, PROG_VERSION);
        j = (int) strlen((char *)tag_buffer);
        if (fwrite(tag_buffer, 1, j, outfp) != j)
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Could not write tag to AES file (3)\n");
            CryptReleaseContext(hProv, 0);
            return  -1;
        }
    }

    // Write out the "container" extension
    buffer[0] = '\0';
    buffer[1] = (unsigned char) 128;
    if (fwrite(buffer, 1, 2, outfp) != 2)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write tag to AES file (4)\n");
        CryptReleaseContext(hProv, 0);
        return  -1;
    }
    memset(tag_buffer, 0, 128);
    if (fwrite(tag_buffer, 1, 128, outfp) != 128)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write tag to AES file (5)\n");
        CryptReleaseContext(hProv, 0);
        return  -1;
    }

    // Write out 0x0000 to indicate that no more extensions exist
    buffer[0] = '\0';
    buffer[1] = '\0';
    if (fwrite(buffer, 1, 2, outfp) != 2)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write tag to AES file (6)\n");
        CryptReleaseContext(hProv, 0);
        return  -1;
    }

    // Create a random IV
    sha256_starts(  &sha_ctx);

    for (i=0; i<256; i++)
    {
        if (!CryptGenRandom(hProv,
                            32,
                            (BYTE *) buffer))
        {
            sprintf(outParam_ErrorMessageBuffer, "Windows is unable to generate random digits");
            CryptReleaseContext(hProv, 0);
            return  -1;
        }
        sha256_update(  &sha_ctx,
                        buffer,
                        32);
    }

    sha256_finish(  &sha_ctx, digest);

    memcpy(IV, digest, 16);

    // We're finished collecting random data
    CryptReleaseContext(hProv, 0);

    // Write the initialization vector to the file
    if (fwrite(IV, 1, 16, outfp) != 16)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write out initialization vector\n");
        return  -1;
    }
    
    // Hash the IV and password 8192 times
    memset(digest, 0, 32);
    memcpy(digest, IV, 16);
    for(i=0; i<8192; i++)
    {
        sha256_starts(  &sha_ctx);
        sha256_update(  &sha_ctx, digest, 32);
#if defined(CONFIG_MZ_PASSBLOB)
        sha256_update(  &sha_ctx,
                        m03x_recovery_key,
                        m03x_recovery_key_len);
#else
#if defined(CONFIG_MZ2_PASSBLOB)
        sha256_update(  &sha_ctx,
                        m04x_recovery_key,
                        m04x_recovery_key_len);
#else
#if defined(CONFIG_MZ3_PASSBLOB)
        sha256_update(  &sha_ctx,
                        mx3_recovery_key,
                        mx3_recovery_key_len);
#else
        sha256_update(  &sha_ctx,
                        (unsigned char*)passwd,
                        (unsigned long)(passlen * sizeof(wchar_t)));
#endif
#endif
#endif
		sha256_finish(  &sha_ctx,
                        digest);
    }

    // Set the AES encryption key
    aes_set_key(&aes_ctx, digest, 256);

    // Set the ipad and opad arrays with values as
    // per RFC 2104 (HMAC).  HMAC is defined as
    //   H(K XOR opad, H(K XOR ipad, text))
    memset(ipad, 0x36, 64);
    memset(opad, 0x5C, 64);

    for(i=0; i<32; i++)
    {
        ipad[i] ^= digest[i];
        opad[i] ^= digest[i];
    }

    sha256_starts(&sha_ctx);
    sha256_update(&sha_ctx, ipad, 64);

    // Encrypt the IV and key used to encrypt the plaintext file,
    // writing that encrypted text to the output file.
    for(i=0; i<48; i+=16)
    {
        // Place the next 16 octets of IV and key buffer into
        // the input buffer.
        memcpy(buffer, iv_key+i, 16);

        // XOR plain text block with previous encrypted
        // output (i.e., use CBC)
        for(j=0; j<16; j++)
        {
            buffer[j] ^= IV[j];
        }

        // Encrypt the contents of the buffer
        aes_encrypt(&aes_ctx, buffer, buffer);
        
        // Concatenate the "text" as we compute the HMAC
        sha256_update(&sha_ctx, buffer, 16);

        // Write the encrypted block
        if (fwrite(buffer, 1, 16, outfp) != 16)
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Could not write iv_key data\n");
            return  -1;
        }
        if (count++ > 0x1000)
        {
            fflush(outfp);
            count = 0;
        }

        // Update the IV (CBC mode)
        memcpy(IV, buffer, 16);
    }

    // Write the HMAC
    sha256_finish(&sha_ctx, digest);
    sha256_starts(&sha_ctx);
    sha256_update(&sha_ctx, opad, 64);
    sha256_update(&sha_ctx, digest, 32);
    sha256_finish(&sha_ctx, digest);
    // Write the encrypted block
    if (fwrite(digest, 1, 32, outfp) != 32)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write iv_key HMAC\n");
        return  -1;
    }

    // Re-load the IV and encryption key with the IV and
    // key to now encrypt the datafile.  Also, reset the HMAC
    // computation.
    memcpy(IV, iv_key, 16);

    // Set the AES encryption key
    aes_set_key(&aes_ctx, iv_key+16, 256);

    // Set the ipad and opad arrays with values as
    // per RFC 2104 (HMAC).  HMAC is defined as
    //   H(K XOR opad, H(K XOR ipad, text))
    memset(ipad, 0x36, 64);
    memset(opad, 0x5C, 64);

    for(i=0; i<32; i++)
    {
        ipad[i] ^= iv_key[i+16];
        opad[i] ^= iv_key[i+16];
    }

    // Wipe the IV and encryption mey from memory
    memset(iv_key, 0, 48);

    sha256_starts(&sha_ctx);
    sha256_update(&sha_ctx, ipad, 64);

    while ((n = (int)fread(buffer, 1, 16, infp)) > 0)
    {
        // XOR plain text block with previous encrypted
        // output (i.e., use CBC)
        for(i=0; i<16; i++)
        {
            buffer[i] ^= IV[i];
        }

        // Encrypt the contents of the buffer
        aes_encrypt(&aes_ctx, buffer, buffer);
        
        // Concatenate the "text" as we compute the HMAC
        sha256_update(&sha_ctx, buffer, 16);

        // Write the encrypted block
        if (fwrite(buffer, 1, 16, outfp) != 16)
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Could not write to output file\n");
            return  -1;
        }
        if (count++ > 0x1000)
        {
            fflush(outfp);
            count = 0;
        }

        
        // Update the IV (CBC mode)
        memcpy(IV, buffer, 16);

        // Assume this number of octets is the file modulo
        aeshdr.last_block_size = n;
    }

    // Check to see if we had a read error
    if (n < 0)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Couldn't read input file\n");
        return  -1;
    }

    // Write the file size modulo
    buffer[0] = (char) (aeshdr.last_block_size & 0x0F);
    if (fwrite(buffer, 1, 1, outfp) != 1)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write the file size modulo\n");
        return  -1;
    }

    // Write the HMAC
    sha256_finish(&sha_ctx, digest);
    sha256_starts(&sha_ctx);
    sha256_update(&sha_ctx, opad, 64);
    sha256_update(&sha_ctx, digest, 32);
    sha256_finish(&sha_ctx, digest);
    if (fwrite(digest, 1, 32, outfp) != 32)
    {
        sprintf(outParam_ErrorMessageBuffer, "Error: Could not write the file HMAC\n");
        return  -1;
    }

    return 0;
}

/*
 *  decrypt_stream_hardcoded
 *
 *  This function is called to decrypt the open data steam "infp".
 */
int decrypt_stream_hardcoded(FILE *infp, FILE *outfp, char *outParam_ErrorMessageBuffer)
{
    aes_context                 aes_ctx;
    sha256_context              sha_ctx;
    aescrypt_hdr                aeshdr;
    sha256_t                    digest;
    unsigned char               IV[16];
    unsigned char               iv_key[48];
    int                         i, j, n, bytes_read;
    unsigned char               buffer[64], buffer2[32];
    unsigned char               *head, *tail;
    unsigned char               ipad[64], opad[64];
    int                         reached_eof = 0;
    int                         count = 0;

    // Read the file header
    if ((bytes_read = (int) fread(&aeshdr, 1, sizeof(aeshdr), infp)) !=
         sizeof(aescrypt_hdr))
    {
        if (feof(infp))
        {
            fprintf(stderr, "Error: Input file is too short.\n");
        }
        else
        {
            perror("Error reading the file header:");
        }
        return  -1;
    }

#if !defined(CONFIG_MZ_PASSBLOB) && !defined(CONFIG_MZ2_PASSBLOB) && !defined(CONFIG_MZ3_PASSBLOB)  // skip check when unpacking
    if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&
          aeshdr.aes[2] == 'S'))
    {
        fprintf(stderr, "Error: Bad file header (not aescrypt file or is corrupted? [%x, %x, %x])\n", aeshdr.aes[0], aeshdr.aes[1], aeshdr.aes[2]);
        return  -1;
    }
#endif

    // Validate the version number and take any version-specific actions
    if (aeshdr.version == 0)
    {
        // Let's just consider the least significant nibble to determine
        // the size of the last block
        aeshdr.last_block_size = (aeshdr.last_block_size & 0x0F);
    }
    else if (aeshdr.version > 0x02)
    {
        fprintf(stderr, "Error: Unsupported AES file version: %d\n",
                aeshdr.version);
        return  -1;
    }

    // Skip over extensions present v2 and later files
    if (aeshdr.version >= 0x02)
    {
        do
        {
            if ((bytes_read = (int) fread(buffer, 1, 2, infp)) != 2)
            {
                if (feof(infp))
                {
                    fprintf(stderr, "Error: Input file is too short.\n");
                }
                else
                {
                    perror("Error reading the file extensions:");
                }
                return  -1;
            }
            // Determine the extension length, zero means no more extensions
            i = j = (((int)buffer[0]) << 8) | (int)buffer[1];
            while (i--)
            {
                if ((bytes_read = (int) fread(buffer, 1, 1, infp)) != 1)
                {
                    if (feof(infp))
                    {
                        fprintf(stderr, "Error: Input file is too short.\n");
                    }
                    else
                    {
                        perror("Error reading the file extensions:");
                    }
                    return  -1;
                }
            }
        } while(j);
    }

    // Read the initialization vector from the file
    if ((bytes_read = (int) fread(IV, 1, 16, infp)) != 16)
    {
        if (feof(infp))
        {
            fprintf(stderr, "Error: Input file is too short.\n");
        }
        else
        {
            perror("Error reading the initialization vector:");
        }
        return  -1;
    }

    // Hash the IV and password 8192 times
    memset(digest, 0, 32);
    memcpy(digest, IV, 16);
    for(i=0; i<8192; i++)
    {
        sha256_starts(  &sha_ctx);
        sha256_update(  &sha_ctx, digest, 32);
#if defined(CONFIG_MZ_PASSBLOB)
        sha256_update(  &sha_ctx,
                        m03x_recovery_key,
                        m03x_recovery_key_len);
#else
#if defined(CONFIG_MZ2_PASSBLOB)
        sha256_update(  &sha_ctx,
                        m04x_recovery_key,
                        m04x_recovery_key_len);
#else
#if defined(CONFIG_MZ3_PASSBLOB)
        sha256_update(  &sha_ctx,
                        mx3_recovery_key,
                        mx3_recovery_key_len);
#else
        sha256_update(  &sha_ctx,
                        (unsigned char*)passwd,
                        (unsigned long)(passlen * sizeof(wchar_t)));
#endif
#endif
#endif
        sha256_finish(  &sha_ctx,
                        digest);
    }

    // Set the AES encryption key
    aes_set_key(&aes_ctx, digest, 256);

    // Set the ipad and opad arrays with values as
    // per RFC 2104 (HMAC).  HMAC is defined as
    //   H(K XOR opad, H(K XOR ipad, text))
    memset(ipad, 0x36, 64);
    memset(opad, 0x5C, 64);

    for(i=0; i<32; i++)
    {
        ipad[i] ^= digest[i];
        opad[i] ^= digest[i];
    }

    sha256_starts(&sha_ctx);
    sha256_update(&sha_ctx, ipad, 64);

    // If this is a version 1 or later file, then read the IV and key
    // for decrypting the bulk of the file.
    if (aeshdr.version >= 0x01)
    {
        for(i=0; i<48; i+=16)
        {
            if ((bytes_read = (int) fread(buffer, 1, 16, infp)) != 16)
            {
                if (feof(infp))
                {
                    sprintf(outParam_ErrorMessageBuffer, "Error: Input file is too short.\n");
                }
                else
                {
                    sprintf(outParam_ErrorMessageBuffer, "Error reading input file IV and key: errno=%d\n", errno);
                }
                return  -1;
            }

            memcpy(buffer2, buffer, 16);

            sha256_update(&sha_ctx, buffer, 16);
            aes_decrypt(&aes_ctx, buffer, buffer);

            // XOR plain text block with previous encrypted
            // output (i.e., use CBC)
            for(j=0; j<16; j++)
            {
                iv_key[i+j] = (buffer[j] ^ IV[j]);
            }

            // Update the IV (CBC mode)
            memcpy(IV, buffer2, 16);
        }

        // Verify that the HMAC is correct
        sha256_finish(&sha_ctx, digest);
        sha256_starts(&sha_ctx);
        sha256_update(&sha_ctx, opad, 64);
        sha256_update(&sha_ctx, digest, 32);
        sha256_finish(&sha_ctx, digest);

        if ((bytes_read = (int) fread(buffer, 1, 32, infp)) != 32)
        {
            if (feof(infp))
            {
                sprintf(outParam_ErrorMessageBuffer, "Error: Input file is too short.\n");
            }
            else
            {
                sprintf(outParam_ErrorMessageBuffer, "Error reading input file digest: errno=%d", errno);
            }
            return  -1;
        }

        if (memcmp(digest, buffer, 32))
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Message has been altered or password is incorrect\n");
            return  -1;
        }

        // Re-load the IV and encryption key with the IV and
        // key to now encrypt the datafile.  Also, reset the HMAC
        // computation.
        memcpy(IV, iv_key, 16);

        // Set the AES encryption key
        aes_set_key(&aes_ctx, iv_key+16, 256);

        // Set the ipad and opad arrays with values as
        // per RFC 2104 (HMAC).  HMAC is defined as
        //   H(K XOR opad, H(K XOR ipad, text))
        memset(ipad, 0x36, 64);
        memset(opad, 0x5C, 64);

        for(i=0; i<32; i++)
        {
            ipad[i] ^= iv_key[i+16];
            opad[i] ^= iv_key[i+16];
        }

        // Wipe the IV and encryption mey from memory
        memset(iv_key, 0, 48);

        sha256_starts(&sha_ctx);
        sha256_update(&sha_ctx, ipad, 64);
    }
    
    // Decrypt the balance of the file

    // Attempt to initialize the ring buffer with contents from the file.
    // Attempt to read 48 octets of the file into the ring buffer.
    if ((bytes_read = (int) fread(buffer, 1, 48, infp)) < 48)
    {
        if (!feof(infp))
        {
            sprintf(outParam_ErrorMessageBuffer, "Error reading input file ring: errno=%d\n", errno);
            return  -1;
        }
        else
        {
            // If there are less than 48 octets, the only valid count
            // is 32 for version 0 (HMAC) and 33 for version 1 or
            // greater files ( file size modulo + HMAC)
            if ((aeshdr.version == 0x00 && bytes_read != 32) ||
                (aeshdr.version >= 0x01 && bytes_read != 33))
            {
                sprintf(outParam_ErrorMessageBuffer, "Error: Input file is corrupt (1:%d).\n",
                        bytes_read);
                return -1;
            }
            else
            {
                // Version 0 files would have the last block size
                // read as part of the header, so let's grab that
                // value now for version 1 files.
                if (aeshdr.version >= 0x01)
                {
                    // The first octet must be the indicator of the
                    // last block size.
                    aeshdr.last_block_size = (buffer[0] & 0x0F);
                }
                // If this initial read indicates there is no encrypted
                // data, then there should be 0 in the last_block_size field
                if (aeshdr.last_block_size != 0)
                {
                    sprintf(outParam_ErrorMessageBuffer, "Error: Input file is corrupt (2).\n");
                    return -1;
                }
            }
            reached_eof = 1;
        }
    }
    head = buffer + 48;
    tail = buffer;

    while(!reached_eof)
    {
        // Check to see if the head of the buffer is past the ring buffer
        if (head == (buffer + 64))
        {
            head = buffer;
        }

        if ((bytes_read = (int) fread(head, 1, 16, infp)) < 16)
        {
            if (!feof(infp))
            {
                sprintf(outParam_ErrorMessageBuffer, "Error reading input file: errno=%d\n", errno);
                return  -1;
            }
            else
            {
                // The last block for v0 must be 16 and for v1 it must be 1
                if ((aeshdr.version == 0x00 && bytes_read > 0) ||
                    (aeshdr.version >= 0x01 && bytes_read != 1))
                {
                    sprintf(outParam_ErrorMessageBuffer, "Error: Input file is corrupt (3:%d).\n",
                            bytes_read);
                    return -1;
                }

                // If this is a v1 file, then the file modulo is located
                // in the ring buffer at tail + 16 (with consideration
                // given to wrapping around the ring, in which case
                // it would be at buffer[0])
                if (aeshdr.version >= 0x01)
                {
                    if ((tail + 16) < (buffer + 64))
                    {
                        aeshdr.last_block_size = (tail[16] & 0x0F);
                    }
                    else
                    {
                        aeshdr.last_block_size = (buffer[0] & 0x0F);
                    }
                }

                // Indicate that we've reached the end of the file
                reached_eof = 1;
            }
        }

        // Process data that has been read.  Note that if the last
        // read operation returned no additional data, there is still
        // one one ciphertext block for us to process if this is a v0 file.
        if ((bytes_read > 0) || (aeshdr.version == 0x00))
        {
            // Advance the head of the buffer forward
            if (bytes_read > 0)
            {
                head += 16;
            }

            memcpy(buffer2, tail, 16);

            sha256_update(&sha_ctx, tail, 16);
            aes_decrypt(&aes_ctx, tail, tail);

            // XOR plain text block with previous encrypted
            // output (i.e., use CBC)
            for(i=0; i<16; i++)
            {
                tail[i] ^= IV[i];
            }

            // Update the IV (CBC mode)
            memcpy(IV, buffer2, 16);

            // If this is the final block, then we may
            // write less than 16 octets
            n = ((!reached_eof) ||
                 (aeshdr.last_block_size == 0)) ? 16 : aeshdr.last_block_size;

            // Write the decrypted block
            if ((i = (int) fwrite(tail, 1, n, outfp)) != n)
            {
                sprintf(outParam_ErrorMessageBuffer, "Error writing decrypted block: errno=%d\n", errno);
                return  -1;
            }
            
            // Move the tail of the ring buffer forward
            tail += 16;
            if (tail == (buffer+64))
            {
                tail = buffer;
            }
        }
    }

    // Verify that the HMAC is correct
    sha256_finish(&sha_ctx, digest);
    sha256_starts(&sha_ctx);
    sha256_update(&sha_ctx, opad, 64);
    sha256_update(&sha_ctx, digest, 32);
    sha256_finish(&sha_ctx, digest);

    // Copy the HMAC read from the file into buffer2
    if (aeshdr.version == 0x00)
    {
        memcpy(buffer2, tail, 16);
        tail += 16;
        if (tail == (buffer + 64))
        {
            tail = buffer;
        }
        memcpy(buffer2+16, tail, 16);
    }
    else
    {
        memcpy(buffer2, tail+1, 15);
        tail += 16;
        if (tail == (buffer + 64))
        {
            tail = buffer;
        }
        memcpy(buffer2+15, tail, 16);
        tail += 16;
        if (tail == (buffer + 64))
        {
            tail = buffer;
        }
        memcpy(buffer2+31, tail, 1);
    }

    if (memcmp(digest, buffer2, 32))
    {
        if (aeshdr.version == 0x00)
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Message has been altered or password is incorrect\n");
        }
        else
        {
            sprintf(outParam_ErrorMessageBuffer, "Error: Message has been altered and should not be trusted\n");
        }

        return -1;
    }

    return 0;
}
